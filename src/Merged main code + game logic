#include <Arduino.h>
#include <Position.h>
#include <string.h>
#include <LCDWIKI_GUI.h>
#include <LCDWIKI_SPI.h>
#include <LcdTetris.h>
#include <MusicPlayer.h>
#include <WaterGun.h>
#include <stdint.h>
#include <ReadPotentiometer.h>

#define SAFETY_THRESHOLD 10
#define MUSIC_SPEED 1.0

uint8_t stress_level;

struct flags{
    byte game_over : 1;
    byte winner : 1;
    byte finished_shooting : 1; 
};

void setup() {
    init();
    sei();
    UBRR0 = 103; //9600 baud rate
    Serial.begin(9600);
    Serial.println("Setup starting...");
    LcdTetris::setup();
    MusicPlayer::setup();
    Serial.println("Music initialized - channels on pins 11, 10, 6");
    WaterGun::setup();
    Serial.println("Setup complete!");
}

void loop() {

    stress_level = ReadPotentiometer::read();

    //If this doesn't compile we can use `static flags loopflags = {0, 0, 0};` but if not this is more readable

    static flags loopflags{
        .game_over = 0,
        .winner = 0,
        .finished_shooting = 0
    };

    if (!loopflags.game_over){
        loopflags.game_over = LcdTetris::update(stress_level);
        if(loopflags.game_over){
            loopflags.winner = LcdTetris::get_score() >= SAFETY_THRESHOLD;
        }
    }

    MusicPlayer::update(!loopflags.game_over || loopflags.winner, stress_level);

    if (loopflags.game_over && !loopflags.winner){
        loopflags.finished_shooting = WaterGun::shoot();
    }

    if (loopflags.game_over && loopflags.finished_shooting){
        //Lock down and wait for reset while displaying thank you message and final score
        while(1){
            LcdTetris::thanks_looser();
            MusicPlayer::update(false, stress_level);
        }
    }
    else if (loopflags.game_over && loopflags.winner){
        while(1){
            LcdTetris::thanks_winner();
            MusicPlayer::update(true, stress_level);
        }
    }

}

namespace LcdTetris {

/// Global Vars
int gameBoard[25][10]; // standard 20x10 tetris board, extra 5 for holding pieces above board
int tickRate = 3; // base speed (you can tie this to stress_level later if you want)
unsigned long timeSinceTick = 0;

int originX = 0;
int originY = 0;
int currentPiece = 0; // 1 = line, 2 = J, 3 = L, 4 = block, 5 = S, 6 = T, 7 = Z
int nextPiece = 0;
int score = 0;

// Position Trackers
int offSetRow = 0;
int offSetCol = 0;
int rotationState = 1;
bool piecePlaced = false;
bool fail = false;

Position currentrotation[4] = {Position(1,0), Position(1,1), Position(1,2), Position(1,3)};
Position previousRender[4] = {Position(1,0), Position(1,1), Position(1,2), Position(1,3)};
int previousOffSet[2] = {0,0}; // offSetX, offSetY

/// Rotation States for each piece
/// line piece states (states 1-4)
Position stateLine1[4] = {Position(1,0), Position(1,1), Position(1,2), Position(1,3)};
Position stateLine2[4] = {Position(0,2), Position(1,2), Position(2,2), Position(3,2)};
Position stateLine3[4] = {Position(2,0), Position(2,1), Position(2,2), Position(2,3)};
Position stateLine4[4] = {Position(0,1), Position(1,1), Position(2,1), Position(3,1)};

/// J-Piece states (states 5-8)
Position stateJ1[4] = {Position(0,0), Position(1,0), Position(1,1), Position(1,2)};
Position stateJ2[4] = {Position(0,1), Position(0,2), Position(1,1), Position(2,1)};
Position stateJ3[4] = {Position(1,0), Position(1,1), Position(1,2), Position(2,2)};
Position stateJ4[4] = {Position(0,1), Position(1,1), Position(2,0), Position(2,1)};

/// L-Piece states (states 9-12)
Position stateL1[4] = {Position(0,2), Position(1,0), Position(1,1), Position(1,2)};
Position stateL2[4] = {Position(0,1), Position(1,1), Position(2,1), Position(2,2)};
Position stateL3[4] = {Position(1,0), Position(1,1), Position(1,2), Position(2,0)};
Position stateL4[4] = {Position(0,0), Position(0,1), Position(1,1), Position(2,1)};

/// Block piece state (state 13)
Position stateBlock1[4] = {Position(0,0), Position(0,1), Position(1,0), Position(1,1)};

/// S-Piece states (states 14-17)
Position stateS1[4] = {Position(0,1), Position(0,2), Position(1,0), Position(1,1)};
Position stateS2[4] = {Position(0,1), Position(1,1), Position(1,2), Position(2,2)};
Position stateS3[4] = {Position(1,1), Position(1,2), Position(2,0), Position(2,1)};
Position stateS4[4] = {Position(0,0), Position(1,0), Position(1,1), Position(2,1)};

/// T-Piece states (states 18-21)
Position stateT1[4] = {Position(0,1), Position(1,0), Position(1,1), Position(1,2)};
Position stateT2[4] = {Position(0,1), Position(1,1), Position(1,2), Position(2,1)};
Position stateT3[4] = {Position(1,0), Position(1,1), Position(1,2), Position(2,1)};
Position stateT4[4] = {Position(0,1), Position(1,0), Position(1,1), Position(2,1)};

/// Z-Piece states (21-24)
Position stateZ1[4] = {Position(0,0), Position(0,1), Position(1,1), Position(1,2)};
Position stateZ2[4] = {Position(0,2), Position(1,1), Position(1,2), Position(2,1)};
Position stateZ3[4] = {Position(1,0), Position(1,1), Position(2,1), Position(2,2)};
Position stateZ4[4] = {Position(0,1), Position(1,0), Position(1,1), Position(2,0)};

/// For now using lib functions for ease of use
// Input pins
const int button1Pin = 6;
const int button2Pin = 5;
const int button3Pin = 4;
int button1Val;
int button2Val;
int button3Val;

int button1LastVal = LOW;
int button2LastVal = LOW;
int button3LastVal = LOW;

// LCD params
#define MODEL ST7796S
#define CS   10    
#define CD   9
#define RST  8
#define LED  7  //if you don't need to control the LED pin,you should set it to -1 and set it to 3.3V

LCDWIKI_SPI mylcd(MODEL,CS,CD,RST,LED);

// colours
#define  BLACK   0x0000
#define BLUE    0x001F
#define RED     0xF800
#define GREEN   0x07E0
#define CYAN    0x07FF
#define MAGENTA 0xF81F
#define YELLOW  0xFFE0
#define ORANGE  0xFB20

// render area of board
int width = mylcd.Get_Display_Width();
int height = mylcd.Get_Display_Height();

void setup() {
  Serial.begin(9600);
  pinMode(button1Pin, INPUT_PULLUP);
  pinMode(button2Pin, INPUT_PULLUP);
  pinMode(button3Pin, INPUT_PULLUP);
  randomSeed(analogRead(0));
  initBoard();
  initPiece();
  mylcd.Init_LCD();
  clearScreen();
}

void loop() {
  ///TODO: remove delay as not allowed in final : (
  // Game loop
  while (!fail) {
    // Make new piece
    if (piecePlaced) {
      initPiece();
      piecePlaced = false;
    }
    processInputs();
    rotationCopy();
    // commented out for now to work out later
    // if ((millis() - timeSinceTick) > (tickRate * 1000)) {
    //   int lastRow = offSetRow;
    //   movePiece(1,0);
    //   if (offSetRow == lastRow) {
    //     placePiece();
    //   }
    // }
    delay(200);
    movePieceDown();
    fail = checkFail();
    timeSinceTick = millis();
    renderPiece();
    renderMisc();
  }
  // Reset Game
  initBoard();
  initPiece();
  clearScreen();
  renderBoard();
  fail = false;
}

// Helper methods
void copyArray(Position* source, Position* destination, int len) {
  memcpy(destination, source, sizeof(source[0]) * len);
}

void rotationCopy() {
  int length = 4;
  switch (currentPiece) {
    case 1:
      if (rotationState == 1) {
        copyArray(stateLine1, currentrotation, length);
      }
      else if (rotationState == 2) {
        copyArray(stateLine2, currentrotation, length);
      }
      else if (rotationState == 3) {
        copyArray(stateLine3, currentrotation, length);
      }
      else {
        copyArray(stateLine4, currentrotation, length);
      }
      break;
    case 2:
      if (rotationState == 1) {
        copyArray(stateJ1, currentrotation, length);
      }
      else if (rotationState == 2) {
        copyArray(stateJ2, currentrotation, length);
      }
      else if (rotationState == 3) {
        copyArray(stateJ3, currentrotation, length);
      }
      else {
        copyArray(stateJ4, currentrotation, length);
      }
      break;
    case 3:
      if (rotationState == 1) {
        copyArray(stateL1, currentrotation, length);
      }
      else if (rotationState == 2) {
        copyArray(stateL2, currentrotation, length);
      }
      else if (rotationState == 3) {
        copyArray(stateL3, currentrotation, length);
      }
      else {
        copyArray(stateL4, currentrotation, length);
      }
      break;
    case 4:
      copyArray(stateBlock1, currentrotation, length);
      break;
    case 5:
      if (rotationState == 1) {
        copyArray(stateS1, currentrotation, length);
      }
      else if (rotationState == 2) {
        copyArray(stateS2, currentrotation, length);
      }
      else if (rotationState == 3) {
        copyArray(stateS3, currentrotation, length);
      }
      else {
        copyArray(stateS4, currentrotation, length);
      }
      break;
    case 6:
      if (rotationState == 1) {
        copyArray(stateT1, currentrotation, length);
      }
      else if (rotationState == 2) {
        copyArray(stateT2, currentrotation, length);
      }
      else if (rotationState == 3) {
        copyArray(stateT3, currentrotation, length);
      }
      else {
        copyArray(stateT4, currentrotation, length);
      }
      break;
    case 7:
      if (rotationState == 1) {
        copyArray(stateZ1, currentrotation, length);
      }
      else if (rotationState == 2) {
        copyArray(stateZ2, currentrotation, length);
      }
      else if (rotationState == 3) {
        copyArray(stateZ3, currentrotation, length);
      }
      else {
        copyArray(stateZ4, currentrotation, length);
      }
      break;
  }
}

bool isCellEmpty(int row, int col) {
  if (gameBoard[row][col] != 0) {
    return false;
  }
  return true;
}

bool isRowEmpty(int row) {
  for (int x = 0; x < 10; x++) {
    if (gameBoard[row][x] != 0) {
      return false;
    }
  }
  return true;
}

bool isRowFull(int row) {
  for (int x = 0; x < 10; x++) {
    if (gameBoard[row][x] == 0) {
      return false;
    }
  }
  return true;
}

/// TODO: broke 
bool pieceFits() {
  rotationCopy();
  for(int x = 0; x < 4; x++) {
    if ((gameBoard[currentrotation[x].getRow() + offSetRow][currentrotation[x].getCol() + offSetCol] != 0) || (currentrotation[x].getRow() + offSetRow > 24) || (currentrotation[x].getCol() + offSetCol  > 9) || (currentrotation[x].getRow() + offSetRow < 0) || (currentrotation[x].getCol() + offSetCol  < 0)) {
      Serial.println("Doesnt Fit!");
      return false;
    }
  }
  return true;

void processInputs() {
  button1Val = digitalRead(button1Pin);
  button2Val = digitalRead(button2Pin);
  button3Val = digitalRead(button3Pin);
  if (button1Val == HIGH) {
    moveLeft();
    Serial.println("B1 pressed");
  }
  if (button2Val == HIGH) {
    moveRight();
    Serial.println("B2 pressed");
  }
  if (button3Val == HIGH) {
    rotatePieceCW();
    Serial.println("B3 pressed");
  }
  button1LastVal = button1Val;
  button2LastVal = button2Val;
  button3LastVal = button3Val;
}

// Board actions
void placePiece() {
  rotationCopy(); // changes the global var
  // TODO: assign values to gameBoard
  for (int x = 0; x < 4; x++) {
    gameBoard[currentrotation[x].getRow() + offSetRow][currentrotation[x].getCol() + offSetCol] = currentPiece;
  }
  piecePlaced = true;
  checkTetris();
  renderBoard();
}

void clearRow(int row) {
  for (int x = 0; x < 10; x++) {
    gameBoard[row][x] = 0;
  }
}

void moveBoardDown() {
// starts at row 24 because those at the lowest row cant be moved down
  for (int x = 23; x > 0; x--) {
    for (int y = 0; y < 10; y++) {
      if (gameBoard[x + 1][y] == 0) {
        gameBoard[x + 1][y] = gameBoard[x][y];
        gameBoard[x][y] = 0;
      }
    }
  }
}

void checkTetris() {
  bool rowCleared = false;
  for (int x = 0; x < 25; x++) {
    if (isRowFull(x)) {
      clearRow(x);
      score++;
      rowCleared = true;
    }
  }
  if (rowCleared) {
    moveBoardDown();
    clearScreen();
  }
  renderBoard();
}

bool checkFail() {
  if(!isRowEmpty(3)) {
    return true;
  }
  return false;
}


// Piece actions
void rotatePieceCW() {
  if (rotationState < 4) {
    rotationState++;
  }
  else {
    rotationState = 1;
  }
  rotationCopy();
  if (!pieceFits()) {
    rotatePieceCCW();
  }
  
}

void rotatePieceCCW() {
  if (rotationState > 1) {
    rotationState--;
  }
  else {
    rotationState = 4;
  }
  rotationCopy();
  if (!pieceFits()) {
    rotatePieceCW();
  }
}
void movePiece(int row, int col) {
  offSetRow += row;
  offSetCol += col;
  
}

void moveLeft() {
  offSetCol--;
  if (!pieceFits()) {
    moveRight();
  }
  Serial.println("offSetCol: ");
  Serial.println(offSetCol);
}
void moveRight() {
  offSetCol++;
  if (!pieceFits()) {
    moveLeft();
  }
  Serial.println("offSetCol: ");
  Serial.println(offSetCol);
}
void movePieceDown() {
  movePiece(1, 0);
  if(!pieceFits()) {
    movePiece(-1,0);
    placePiece();
  }
  if (offSetRow >= 23) {
    placePiece();
  }
  Serial.println("offSetRow: ");
  Serial.println(offSetRow);
}


// System
void initBoard() {
  for (int x = 0; x < 25; x++) {
    for (int y = 0; y < 10; y++) {
      gameBoard[x][y]= 0;
    }
  }
  score = 0;
}

///TODO: fix for actual current and next piece lmao
void initPiece() {
  originX = 0;
  originY = 0;
  offSetRow = 0;
  offSetCol = 0;
  rotationState = 1;
  if (nextPiece == 0) {
    nextPiece = random(1, 8);
  }

  // picks a random piece and centers it
  currentPiece = nextPiece;
  nextPiece = random(1, 8); // 1-7
  offSetRow = 3;
  offSetCol = 5;
  rotationCopy();
  //Serial.println(currentPiece);
}


/// Rendering Methods
void clearScreen() {
  mylcd.Fill_Screen(BLACK);
}

void setColor(int ID) {
  switch (ID) {
    case 1:
      mylcd.Set_Draw_color(CYAN);
      break;
    case 2:
      mylcd.Set_Draw_color(BLUE);
      break;
    case 3:
      mylcd.Set_Draw_color(ORANGE);
      break;
    case 4:
      mylcd.Set_Draw_color(YELLOW);
      break;
    case 5:
      mylcd.Set_Draw_color(GREEN);
      break;
    case 6:
      mylcd.Set_Draw_color(MAGENTA);
      break;
    case 7:
      mylcd.Set_Draw_color(RED);
      break;
  }
}

// Render score, and next piece
void renderMisc() {
  mylcd.Set_Text_Mode(0);
  // Score Render
  mylcd.Set_Text_colour(CYAN);
  mylcd.Set_Text_Size(2);
  mylcd.Print_Number_Int(score, 200, 104, 0, ' ', 16);

  // Next Piece text because I dont feel like rendering the next piece
  mylcd.Set_Text_colour(BLUE);
  mylcd.Set_Text_Size(2);
  switch (currentPiece) {
    case 1:
      mylcd.Print_String("I Piece", 200, 120);
      break;
    case 2:
      mylcd.Print_String("J Piece", 200, 120);
      break;
    case 3:
      mylcd.Print_String("L Piece", 200, 120);
      break;
    case 4:
      mylcd.Print_String("Block Piece", 200, 120);
      break;
    case 5:
      mylcd.Print_String("S Piece", 200, 120);
      break;
    case 6:
      mylcd.Print_String("T Piece", 200, 120);
      break;
    case 7:
      mylcd.Print_String("Z Piece", 200, 120);
      break;
  }
}

// To only be called when placePiece() is called
void renderBoard() {
  int x1 = 0;
  int y1 = 0;
  int size = 19;
  // draw rects
  for (int x = 0; x < 25; x++) {
    for (int y = 0; y < 10; y++) {
      if (gameBoard[x][y] >= 1) {
        setColor(gameBoard[x][y]);
        mylcd.Draw_Rectangle(x1, y1, x1 + size, y1 + size);
      }
      x1 = x1 + size;
    }
    y1 = y1 + size;
    x1 = 0;
  }
  x1 = 0;
  y1 = 0;
  // fill rects
  for (int x = 0; x < 25; x++) {
    for (int y = 0; y < 10; y++) {
      if (gameBoard[x][y] >= 1) {
        setColor(gameBoard[x][y]);
        mylcd.Fill_Rectangle(x1, y1, x1 + size, y1 + size);
      }
      x1 = x1 + size;
    }
    y1 = y1 + size;
    x1 = 0;
  }
  x1 = 0;
  y1 = 0;
}

void renderPiece() {
  mylcd.Set_Draw_color(0, 0, 0);
  // Draw over old piece
  int startingX = 0;
  int startingY = 0;
  int endX = 0;
  int endY = 0;
  int size = 19;
  for (int x = 0; x < 4; x++) {
    if (previousRender[x].getRow() == 0 && previousOffSet[0] == 0) {
      startingY =  0;
      endY = 19;
    }
    else {
      startingY = (previousRender[x].getRow() + previousOffSet[0]) * size;
      endY = (previousRender[x].getRow() + previousOffSet[0] + 1) * size;
    } // first block being overlapped with second?
    if (previousRender[x].getCol() == 0 && previousOffSet[1] == 0) {
      startingX = 0;
      endX = 19;
    }
    else {
      startingX = (previousRender[x].getCol() + previousOffSet[1]) * size;
      endX = (previousRender[x].getCol() + previousOffSet[1] + 1) * size; // this seemed to fix it for now
    }
    mylcd.Draw_Rectangle(startingX, startingY, endX, endY);
  }

   // render peice in play, assumes rotation was copied at some point into piece
  setColor(currentPiece);
  copyArray(currentrotation, previousRender, 4);
  previousOffSet[0] = offSetRow;
  previousOffSet[1] = offSetCol;
  for (int x = 0; x < 4; x++) {
    if (currentrotation[x].getRow() == 0 && offSetRow == 0) {
      startingY =  0;
      endY = 19;
    }
    else {
      startingY = (currentrotation[x].getRow() + offSetRow) * size;
      endY = (currentrotation[x].getRow() + offSetRow + 1) * size;
    } // first block being overlapped with second?
    if (currentrotation[x].getCol() == 0 && offSetCol == 0) {
      startingX = 0;
      endX = 19;
    }
    else {
      startingX = (currentrotation[x].getCol() + offSetCol) * size;
      endX = (currentrotation[x].getCol() + offSetCol + 1) * size; // this seemed to fix it for now
    }
    
    // Serial.print("offSetRow: ");
    // Serial.println(offSetRow);
    // Serial.print("offSetCol: ");
    // Serial.println(offSetCol);
    // Serial.print("Piece Row: ");
    // Serial.println(currentrotation[x].getRow());
    // Serial.print("Piece Col: ");
    // Serial.println(currentrotation[x].getCol());

    // Serial.print("starting X: ");
    // Serial.println(startingX);
    // Serial.print("starting Y: ");
    // Serial.println(startingY);
    // Serial.print("endX: ");
    // Serial.println(endX);
    // Serial.print("endY: ");
    // Serial.println(endY);
    mylcd.Draw_Rectangle(startingX, startingY, endX, endY);
    //mylcd.Draw_Rectangle(0, 0, 19, 19);
  }
}



